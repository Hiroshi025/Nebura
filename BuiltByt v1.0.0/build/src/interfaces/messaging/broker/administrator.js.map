{"version":3,"file":"administrator.js","sources":["src/interfaces/messaging/broker/administrator.ts"],"sourceRoot":"/","sourcesContent":["import chalk from \"chalk\";\r\nimport { NextFunction, Request, Response } from \"express\";\r\n\r\nimport { main } from \"@/main\";\r\nimport { logWithLabel } from \"@/shared/utils/functions/console\";\r\nimport emojis from \"@config/json/emojis.json\";\r\nimport { config } from \"@utils/config\";\r\n\r\nimport { Notification } from \"./notification\";\r\n\r\n/**\r\n * Class to manage IP address blocking.\r\n */\r\nexport class IPBlocker {\r\n  private static instance: IPBlocker;\r\n  private notifications: typeof config.moderation.notifications;\r\n  private blockedIPs: Set<string> = new Set();\r\n  private lastUpdate: Date = new Date(0);\r\n\r\n  /**\r\n   * Private constructor to implement the Singleton pattern.\r\n   */\r\n  private constructor() {\r\n    this.notifications = config.moderation.notifications;\r\n    this.loadBlockedIPs();\r\n    // Update every hour\r\n    setInterval(() => this.loadBlockedIPs(), 60 * 60 * 1000);\r\n    // Auto-unblock expired IPs every 10 minutes\r\n    setInterval(() => this.autoUnblockExpiredIPs(), 10 * 60 * 1000);\r\n  }\r\n\r\n  /**\r\n   * Gets the unique instance of IPBlocker.\r\n   * @returns The IPBlocker instance.\r\n   */\r\n  public static getInstance(): IPBlocker {\r\n    if (!IPBlocker.instance) {\r\n      IPBlocker.instance = new IPBlocker();\r\n    }\r\n    return IPBlocker.instance;\r\n  }\r\n\r\n  /**\r\n   * Loads blocked IP addresses from the database.\r\n   * @returns A promise that resolves when the IPs are loaded.\r\n   */\r\n  private async loadBlockedIPs(): Promise<void> {\r\n    try {\r\n      logWithLabel(\"custom\", \"Loading blocked IPs...\", {\r\n        customLabel: \"IP\",\r\n      });\r\n      const now = new Date();\r\n      const activeBlocks = await main.prisma.blockedIP.findMany({\r\n        where: {\r\n          isActive: true,\r\n          OR: [{ expiresAt: { gt: now } }, { expiresAt: undefined }],\r\n        },\r\n      });\r\n\r\n      // Asegura que activeBlocks sea siempre un array\r\n      this.blockedIPs = new Set((activeBlocks ?? []).map((block) => block.ipAddress));\r\n      this.lastUpdate = new Date();\r\n      logWithLabel(\r\n        \"custom\",\r\n        [\r\n          `${this.blockedIPs.size} Ips is blocked and loaded in memory.`,\r\n          `  ${chalk.grey(`${emojis.moderator}   Last update: ${this.lastUpdate.toISOString()}`)}`,\r\n        ].join(\"\\n\"),\r\n        {\r\n          customLabel: \"IP\",\r\n        },\r\n      );\r\n    } catch (error) {\r\n      logWithLabel(\"custom\", `Error loading blocked IPs: ${error}`, {\r\n        customLabel: \"IP\",\r\n        context: {\r\n          error: error,\r\n          blockedIPs: this.blockedIPs,\r\n          lastUpdate: this.lastUpdate,\r\n        },\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Automatically unblocks IPs whose block duration has expired.\r\n   */\r\n  private async autoUnblockExpiredIPs(): Promise<void> {\r\n    try {\r\n      const now = new Date();\r\n      const expiredBlocks = await main.prisma.blockedIP.findMany({\r\n        where: {\r\n          isActive: true,\r\n          expiresAt: { lte: now },\r\n        },\r\n      });\r\n\r\n      for (const block of expiredBlocks) {\r\n        await this.unblockIP(block.ipAddress);\r\n      }\r\n\r\n      if (expiredBlocks.length > 0) {\r\n        logWithLabel(\r\n          \"custom\",\r\n          `${expiredBlocks.length} expired IP blocks have been automatically unblocked.`,\r\n          {\r\n            customLabel: \"IP\",\r\n          },\r\n        );\r\n      }\r\n    } catch (error) {\r\n      logWithLabel(\"custom\", `Error during auto-unblock of expired IPs: ${error}`, {\r\n        customLabel: \"IP\",\r\n        context: {\r\n          error: error,\r\n          blockedIPs: this.blockedIPs,\r\n          lastUpdate: this.lastUpdate,\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Blocks an IP address.\r\n   * @param ipAddress - The IP address to block.\r\n   * @param userId - The ID of the user performing the block.\r\n   * @param reason - The reason for the block (optional).\r\n   * @param expiresAt - The expiration date of the block (optional).\r\n   * @returns A promise that resolves when the IP is blocked.\r\n   */\r\n  public async blockIP(\r\n    ipAddress: string,\r\n    userId: string,\r\n    reason?: string,\r\n    expiresAt?: Date,\r\n  ): Promise<void> {\r\n    try {\r\n      await main.prisma.blockedIP.upsert({\r\n        where: { ipAddress },\r\n        update: {\r\n          reason,\r\n          blockedBy: userId,\r\n          expiresAt: expiresAt ? expiresAt.toISOString() : undefined,\r\n          isActive: true,\r\n        },\r\n        create: {\r\n          ipAddress,\r\n          reason,\r\n          blockedBy: userId,\r\n          expiresAt: expiresAt ? expiresAt.toISOString() : null,\r\n          isActive: true,\r\n        },\r\n      });\r\n\r\n      this.blockedIPs.add(ipAddress);\r\n      logWithLabel(\r\n        \"api\",\r\n        `[IPBlocker] IP ${ipAddress} blocked by ${userId}. Reason: ${reason || \"Not specified\"}`,\r\n      );\r\n\r\n      // Send notification if webhook token is valid\r\n      if (this.notifications.webhooks.token) {\r\n        const notification = new Notification();\r\n        await notification.sendWebhookNotification(\r\n          \"IP Blocked\",\r\n          `The IP address ${ipAddress} has been blocked.`,\r\n          \"#FF0000\",\r\n          [\r\n            { name: \"Blocked By\", value: userId, inline: true },\r\n            { name: \"Reason\", value: reason || \"Not specified\", inline: true },\r\n            { name: \"Expires At\", value: expiresAt?.toISOString() || \"Indefinite\", inline: true },\r\n          ],\r\n        );\r\n      }\r\n    } catch (error) {\r\n      logWithLabel(\"api\", `[IPBlocker] Error blocking IP ${ipAddress}: ${error}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unblocks an IP address.\r\n   * @param ipAddress - The IP address to unblock.\r\n   * @returns A promise that resolves when the IP is unblocked.\r\n   */\r\n  public async unblockIP(ipAddress: string): Promise<void> {\r\n    try {\r\n      await main.prisma.blockedIP.updateMany({\r\n        where: { ipAddress },\r\n        data: { isActive: false },\r\n      });\r\n\r\n      this.blockedIPs.delete(ipAddress);\r\n      logWithLabel(\"api\", `[IPBlocker] IP ${ipAddress} unblocked.`);\r\n\r\n      // Send notification if webhook token is valid\r\n      if (this.notifications.webhooks.token) {\r\n        const notification = new Notification();\r\n        await notification.sendWebhookNotification(\r\n          \"IP Unblocked\",\r\n          `The IP address ${ipAddress} has been unblocked.`,\r\n          \"#00FF00\",\r\n          [{ name: \"IP Address\", value: ipAddress, inline: true }],\r\n        );\r\n      }\r\n    } catch (error) {\r\n      logWithLabel(\"api\", `[IPBlocker] Error unblocking IP ${ipAddress}: ${error}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if an IP address is blocked.\r\n   * @param ipAddress - The IP address to check.\r\n   * @returns `true` if the IP is blocked, otherwise `false`.\r\n   */\r\n  public isIPBlocked(ipAddress: string): boolean {\r\n    return this.blockedIPs.has(ipAddress);\r\n  }\r\n\r\n  /**\r\n   * Gets the middleware to block requests from blocked IPs.\r\n   * @returns Express middleware.\r\n   */\r\n  public getMiddleware() {\r\n    return (req: Request, res: Response, next: NextFunction) => {\r\n      const clientIp = req.ip || req.headers[\"x-forwarded-for\"] || req.socket.remoteAddress;\r\n\r\n      if (typeof clientIp !== \"string\") {\r\n        return res.status(400).json({ error: \"Could not determine IP address\" });\r\n      }\r\n\r\n      // Extract the real IP if behind a proxy\r\n      const realIp = clientIp.split(\",\")[0].trim();\r\n\r\n      if (this.isIPBlocked(realIp)) {\r\n        logWithLabel(\"api\", `[IPBlocker] IP ${realIp} blocked. Access denied.`);\r\n        return res.status(403).json({\r\n          error: \"Access denied\",\r\n          reason: \"Your IP address has been blocked\",\r\n        });\r\n      }\r\n\r\n      next();\r\n      return;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Retrieves a paginated list of blocked IP addresses.\r\n   * @param page - Page number (default is 1).\r\n   * @param limit - Number of results per page (default is 20).\r\n   * @returns A promise that resolves with the list of blocked IPs.\r\n   */\r\n  public async getBlockedIPs(page: number = 1, limit: number = 20) {\r\n    const skip = (page - 1) * limit;\r\n    return await main.prisma.blockedIP.findMany({\r\n      where: { isActive: true },\r\n      skip,\r\n      take: limit,\r\n      orderBy: { createdAt: \"desc\" },\r\n      include: { blockedUser: { select: { id: true, name: true, email: true } } },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Logs a failed attempt from an IP address.\r\n   * If the allowed attempts are exceeded, the IP will be automatically blocked.\r\n   * @param ipAddress - The IP address of the failed attempt.\r\n   * @returns A promise that resolves when the attempt is logged.\r\n   */\r\n  public async recordFailedAttempt(ipAddress: string): Promise<void> {\r\n    try {\r\n      // Log the failed attempt in the database\r\n      await main.prisma.failedAttempt.create({\r\n        data: {\r\n          ipAddress,\r\n          attemptTime: new Date(),\r\n        },\r\n      });\r\n\r\n      // Check if it exceeds the attempt limit\r\n      const attemptCount = await main.prisma.failedAttempt.count({\r\n        where: {\r\n          ipAddress,\r\n          attemptTime: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }, // Last 24 hours\r\n        },\r\n      });\r\n\r\n      // Automatically block after 5 failed attempts\r\n      if (attemptCount >= 5) {\r\n        await this.blockIP(\r\n          ipAddress,\r\n          \"system\",\r\n          \"Automatic block due to multiple failed attempts\",\r\n          new Date(Date.now() + 24 * 60 * 60 * 1000), // Block for 24 hours\r\n        );\r\n\r\n        // Send notification if webhook token is valid\r\n        if (this.notifications.webhooks.token) {\r\n          const notification = new Notification();\r\n          await notification.sendWebhookNotification(\r\n            \"Automatic IP Block\",\r\n            `The IP address ${ipAddress} has been automatically blocked due to multiple failed attempts.`,\r\n            \"#FFA500\",\r\n            [\r\n              { name: \"IP Address\", value: ipAddress, inline: true },\r\n              { name: \"Reason\", value: \"Multiple failed attempts\", inline: true },\r\n              { name: \"Blocked Duration\", value: \"24 hours\", inline: true },\r\n            ],\r\n          );\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logWithLabel(\r\n        \"api\",\r\n        `[IPBlocker] Error logging failed attempt from IP ${ipAddress}: ${error}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debug_id":"0b97b26d-5f29-514a-bf0b-985f29d83af7"}