{"version":3,"file":"token.js","sources":["src/shared/utils/token.ts"],"sourceRoot":"/","sourcesContent":["import { compare, hash } from \"bcryptjs\";\r\nimport { sign, verify } from \"jsonwebtoken\";\r\n\r\nimport { DomainError } from \"@/shared/adapters/extends/error.extend\";\r\n\r\n/**\r\n * Generates a JSON Web Token (JWT) for the given user ID (email).\r\n *\r\n * @param {string} id - The user ID (must be a valid email).\r\n * @returns {string} The signed JWT.\r\n * @throws {ServerError} If the provided ID is not a valid email.\r\n *\r\n * @example\r\n * const token = signToken(\"user@example.com\");\r\n * console.log(token);\r\n */\r\nconst signToken = (id: string): string => {\r\n  if (!process.env.JWT_SECRET) throw new DomainError(\"No JWT secret provided\");\r\n\r\n  const jwt = sign({ id }, process.env.JWT_SECRET, {\r\n    expiresIn: \"1d\",\r\n  });\r\n\r\n  return jwt;\r\n};\r\n\r\n/**\r\n * Validates a given JSON Web Token (JWT).\r\n *\r\n * @param {string} jwt - The JWT to validate.\r\n * @returns {string | object} Returns the decoded token if valid, or \"not_auth\" if invalid.\r\n *\r\n * @example\r\n * const tokenData = await getToken(\"your.jwt.token\");\r\n * if (tokenData === \"not_auth\") {\r\n *   console.log(\"Token is invalid or expired\");\r\n * } else {\r\n *   console.log(\"Token is valid:\", tokenData);\r\n * }\r\n */\r\nconst getToken = async (jwt: string): Promise<string | object> => {\r\n  if (!process.env.JWT_SECRET) throw new DomainError(\"No JWT secret provided\");\r\n  if (!jwt) return \"not_auth\";\r\n\r\n  const isOK = verify(jwt, process.env.JWT_SECRET);\r\n  if (!isOK) return \"not_auth\";\r\n\r\n  return isOK;\r\n};\r\n\r\n/**\r\n * Encrypts a password using bcrypt with a salt round of 8.\r\n *\r\n * @param {string} pass - The plain text password to encrypt.\r\n * @returns {Promise<string>} The hashed password.\r\n *\r\n * @example\r\n * const hashedPassword = await encrypt(\"my_secure_password\");\r\n * console.log(hashedPassword);\r\n */\r\nconst encrypt = async (pass: string): Promise<string> => {\r\n  const passwordHash = await hash(pass, 8);\r\n  return passwordHash;\r\n};\r\n\r\n/**\r\n * Verifies a plain text password against a hashed password.\r\n *\r\n * @param {string} pass - The plain text password.\r\n * @param {string} passHash - The hashed password to compare against.\r\n * @returns {Promise<boolean>} Returns `true` if the password matches, otherwise `false`.\r\n *\r\n * @example\r\n * const isValid = await verified(\"my_secure_password\", hashedPassword);\r\n * console.log(isValid); // true or false\r\n */\r\nconst verified = async (pass: string, passHash: string): Promise<boolean> => {\r\n  const isCorrect = await compare(pass, passHash);\r\n  return isCorrect;\r\n};\r\n\r\nexport { encrypt, getToken, signToken, verified };\r\n"],"names":[],"mappings":";;;;;AAAA,uCAAyC;AACzC,+CAA4C;AAE5C,yEAAqE;AAErE;;;;;;;;;;GAUG;AACH,MAAM,SAAS,GAAG,CAAC,EAAU,EAAU,EAAE;IACvC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU;QAAE,MAAM,IAAI,0BAAW,CAAC,wBAAwB,CAAC,CAAC;IAE7E,MAAM,GAAG,GAAG,IAAA,mBAAI,EAAC,EAAE,EAAE,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE;QAC/C,SAAS,EAAE,IAAI;KAChB,CAAC,CAAC;IAEH,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAyD0B,8BAAS;AAvDrC;;;;;;;;;;;;;GAaG;AACH,MAAM,QAAQ,GAAG,KAAK,EAAE,GAAW,EAA4B,EAAE;IAC/D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU;QAAE,MAAM,IAAI,0BAAW,CAAC,wBAAwB,CAAC,CAAC;IAC7E,IAAI,CAAC,GAAG;QAAE,OAAO,UAAU,CAAC;IAE5B,MAAM,IAAI,GAAG,IAAA,qBAAM,EAAC,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACjD,IAAI,CAAC,IAAI;QAAE,OAAO,UAAU,CAAC;IAE7B,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAiCgB,4BAAQ;AA/B1B;;;;;;;;;GASG;AACH,MAAM,OAAO,GAAG,KAAK,EAAE,IAAY,EAAmB,EAAE;IACtD,MAAM,YAAY,GAAG,MAAM,IAAA,eAAI,EAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACzC,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC;AAkBO,0BAAO;AAhBhB;;;;;;;;;;GAUG;AACH,MAAM,QAAQ,GAAG,KAAK,EAAE,IAAY,EAAE,QAAgB,EAAoB,EAAE;IAC1E,MAAM,SAAS,GAAG,MAAM,IAAA,kBAAO,EAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAChD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEqC,4BAAQ","debug_id":"e7844f8e-98b8-511b-8c96-c11516cbb6e4"}